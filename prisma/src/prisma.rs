// Code generated by Prisma Client Rust. DO NOT EDIT

#![allow(warnings, unused)]
use prisma_client_rust::{
    bigdecimal::{self, FromPrimitive},
    chrono,
    datamodel::parse_configuration,
    operator::Operator,
    prisma_models::{InternalDataModelBuilder, PrismaValue},
    queries::{QueryContext, QueryInfo, Result as QueryResult},
    query_core::{
        executor, schema_builder, BuildMode, CoreError, InterpreterError, QueryExecutor,
        QueryGraphBuilderError, QuerySchema, QueryValue, Selection,
    },
    serde_json, transform_equals, BatchResult, Direction, ManyArgs, SerializedWhere,
    SerializedWhereValue, UniqueArgs,
};
pub use prisma_client_rust::{queries::Error as QueryError, NewClientError};
use serde::{Deserialize, Serialize};
use std::path::Path;
use std::sync::Arc;
static DATAMODEL_STR : & 'static str = "// This is your Prisma schema file,\n// learn more about it in the docs: https://pris.ly/d/prisma-schema\n\ngenerator client {\n  provider = \"cargo prisma\"\n  output   = \"./src/prisma.rs\"\n}\n\ndatasource db {\n  provider = \"mysql\"\n  url      = env(\"DATABASE_URL\")\n}\n\nmodel User {\n  id                       String @id @default(cuid())\n  sessionToken             String\n  twitterAccessToken       String @unique\n  twitterAccessTokenSecret String @unique\n\n  createdAt     DateTime        @default(now())\n  updatedAt     DateTime        @updatedAt\n  BlockList     BlockList[]\n  IncomingBlock IncomingBlock[]\n}\n\nmodel BlockList {\n  id String @id @default(cuid())\n\n  owner   User   @relation(fields: [ownerId], references: [id], onDelete: Cascade, onUpdate: Cascade)\n  ownerId String @unique\n\n  createdAt     DateTime        @default(now())\n  updatedAt     DateTime        @updatedAt\n  BlockListItem BlockListItem[]\n}\n\nmodel BlockListItem {\n  id String @id @default(cuid())\n\n  blockList   BlockList @relation(fields: [blockListId], references: [id], onDelete: Cascade, onUpdate: Cascade)\n  blockListId String\n\n  twitterAt String\n  twitterId String\n\n  createdAt     DateTime        @default(now())\n  updatedAt     DateTime        @updatedAt\n  IncomingBlock IncomingBlock[]\n}\n\nmodel IncomingBlock {\n  id String @id @default(cuid())\n\n  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)\n  userId String\n\n  blockListItem   BlockListItem @relation(fields: [blockListItemId], references: [id], onDelete: Cascade, onUpdate: Cascade)\n  blockListItemId String\n\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n}\n" ;
static DATABASE_STR: &'static str = "mysql";
pub async fn new_client() -> Result<_prisma::PrismaClient, NewClientError> {
    let config = parse_configuration(DATAMODEL_STR)?.subject;
    let source = config
        .datasources
        .first()
        .expect("Pleasy supply a datasource in your schema.prisma file");
    let url = if let Some(url) = source.load_shadow_database_url()? {
        url
    } else {
        source.load_url(|key| std::env::var(key).ok())?
    };
    let url = if url.starts_with("file:") {
        let path = url.split(":").nth(1).unwrap();
        if Path::new("./schema.prisma").exists() {
            url
        } else if Path::new("./prisma/schema.prisma").exists() {
            format!("file:./prisma/{}", path)
        } else {
            url
        }
    } else {
        url
    };
    new_client_with_url(&url).await
}
pub async fn new_client_with_url(url: &str) -> Result<_prisma::PrismaClient, NewClientError> {
    let config = parse_configuration(DATAMODEL_STR)?.subject;
    let source = config
        .datasources
        .first()
        .expect("Pleasy supply a datasource in your schema.prisma file");
    let (db_name, executor) = executor::load(&source, &[], &url).await?;
    let internal_model = InternalDataModelBuilder::new(DATAMODEL_STR).build(db_name);
    let query_schema = Arc::new(schema_builder::build(
        internal_model,
        BuildMode::Modern,
        true,
        source.capabilities(),
        vec![],
        source.referential_integrity(),
    ));
    executor.primary_connector().get_connection().await?;
    Ok(PrismaClient::_new(executor, query_schema))
}
pub mod user {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::Id(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::IdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::IdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::IdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::IdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::IdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::IdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::IdEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::IdNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
    }
    pub mod session_token {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::SessionTokenEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::SessionToken(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::SessionTokenInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::SessionTokenNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::SessionTokenLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::SessionTokenLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::SessionTokenGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::SessionTokenGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::SessionTokenContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::SessionTokenStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::SessionTokenEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::SessionTokenNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetSessionToken(value.0)
            }
        }
    }
    pub mod twitter_access_token {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::TwitterAccessTokenEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::TwitterAccessToken(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::TwitterAccessToken(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::TwitterAccessTokenInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::TwitterAccessTokenNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::TwitterAccessTokenLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::TwitterAccessTokenLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::TwitterAccessTokenGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::TwitterAccessTokenGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::TwitterAccessTokenContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::TwitterAccessTokenStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::TwitterAccessTokenEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::TwitterAccessTokenNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetTwitterAccessToken(value.0)
            }
        }
    }
    pub mod twitter_access_token_secret {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::TwitterAccessTokenSecretEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::TwitterAccessTokenSecret(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::TwitterAccessTokenSecret(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::TwitterAccessTokenSecretInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::TwitterAccessTokenSecretNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::TwitterAccessTokenSecretLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::TwitterAccessTokenSecretLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::TwitterAccessTokenSecretGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::TwitterAccessTokenSecretGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::TwitterAccessTokenSecretContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::TwitterAccessTokenSecretStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::TwitterAccessTokenSecretEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::TwitterAccessTokenSecretNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetTwitterAccessTokenSecret(value.0)
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::CreatedAtInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::CreatedAtNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtNot(value)
        }
        pub struct Set(chrono::DateTime<chrono::FixedOffset>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetCreatedAt(value.0)
            }
        }
    }
    pub mod updated_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::UpdatedAt(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::UpdatedAtInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::UpdatedAtNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtNot(value)
        }
        pub struct Set(chrono::DateTime<chrono::FixedOffset>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUpdatedAt(value.0)
            }
        }
    }
    pub mod block_list {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<block_list::WhereParam>) -> WhereParam {
            WhereParam::BlockListSome(value)
        }
        pub fn every(value: Vec<block_list::WhereParam>) -> WhereParam {
            WhereParam::BlockListEvery(value)
        }
        pub fn none(value: Vec<block_list::WhereParam>) -> WhereParam {
            WhereParam::BlockListNone(value)
        }
        pub struct Fetch {
            args: block_list::ManyArgs,
        }
        impl Fetch {
            pub fn with(mut self, params: impl Into<block_list::WithParam>) -> Self {
                self.args = self.args.with(params.into());
                self
            }
            pub fn order_by(mut self, param: block_list::OrderByParam) -> Self {
                self.args = self.args.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.args = self.args.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.args = self.args.take(value);
                self
            }
            pub fn cursor(mut self, value: impl Into<block_list::Cursor>) -> Self {
                self.args = self.args.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::BlockList(fetch.args)
            }
        }
        pub fn fetch(params: Vec<block_list::WhereParam>) -> Fetch {
            Fetch {
                args: block_list::ManyArgs::new(params),
            }
        }
        pub fn link<T: From<Link>>(params: Vec<block_list::UniqueWhereParam>) -> T {
            Link(params).into()
        }
        pub fn unlink(params: Vec<block_list::UniqueWhereParam>) -> SetParam {
            SetParam::UnlinkBlockList(params)
        }
        pub struct Link(Vec<block_list::UniqueWhereParam>);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkBlockList(value.0)
            }
        }
    }
    pub mod incoming_block {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<incoming_block::WhereParam>) -> WhereParam {
            WhereParam::IncomingBlockSome(value)
        }
        pub fn every(value: Vec<incoming_block::WhereParam>) -> WhereParam {
            WhereParam::IncomingBlockEvery(value)
        }
        pub fn none(value: Vec<incoming_block::WhereParam>) -> WhereParam {
            WhereParam::IncomingBlockNone(value)
        }
        pub struct Fetch {
            args: incoming_block::ManyArgs,
        }
        impl Fetch {
            pub fn with(mut self, params: impl Into<incoming_block::WithParam>) -> Self {
                self.args = self.args.with(params.into());
                self
            }
            pub fn order_by(mut self, param: incoming_block::OrderByParam) -> Self {
                self.args = self.args.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.args = self.args.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.args = self.args.take(value);
                self
            }
            pub fn cursor(mut self, value: impl Into<incoming_block::Cursor>) -> Self {
                self.args = self.args.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::IncomingBlock(fetch.args)
            }
        }
        pub fn fetch(params: Vec<incoming_block::WhereParam>) -> Fetch {
            Fetch {
                args: incoming_block::ManyArgs::new(params),
            }
        }
        pub fn link<T: From<Link>>(params: Vec<incoming_block::UniqueWhereParam>) -> T {
            Link(params).into()
        }
        pub fn unlink(params: Vec<incoming_block::UniqueWhereParam>) -> SetParam {
            SetParam::UnlinkIncomingBlock(params)
        }
        pub struct Link(Vec<incoming_block::UniqueWhereParam>);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkIncomingBlock(value.0)
            }
        }
    }
    pub fn _outputs() -> Vec<Selection> {
        [
            "id",
            "sessionToken",
            "twitterAccessToken",
            "twitterAccessTokenSecret",
            "createdAt",
            "updatedAt",
        ]
        .into_iter()
        .map(|o| {
            let builder = Selection::builder(o);
            builder.build()
        })
        .collect()
    }
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "sessionToken")]
        pub session_token: String,
        #[serde(rename = "twitterAccessToken")]
        pub twitter_access_token: String,
        #[serde(rename = "twitterAccessTokenSecret")]
        pub twitter_access_token_secret: String,
        #[serde(rename = "createdAt")]
        pub created_at: chrono::DateTime<chrono::FixedOffset>,
        #[serde(rename = "updatedAt")]
        pub updated_at: chrono::DateTime<chrono::FixedOffset>,
        #[serde(rename = "BlockList")]
        pub block_list: Option<Vec<super::block_list::Data>>,
        #[serde(rename = "IncomingBlock")]
        pub incoming_block: Option<Vec<super::incoming_block::Data>>,
    }
    impl Data {
        pub fn block_list(&self) -> Result<&Vec<super::block_list::Data>, &'static str> {
            self.block_list.as_ref().ok_or(
                "Attempted to access 'block_list' but did not fetch it using the .with() syntax",
            )
        }
        pub fn incoming_block(&self) -> Result<&Vec<super::incoming_block::Data>, &'static str> {
            self . incoming_block . as_ref () . ok_or ("Attempted to access 'incoming_block' but did not fetch it using the .with() syntax")
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        BlockList(super::block_list::ManyArgs),
        IncomingBlock(super::incoming_block::ManyArgs),
    }
    impl Into<Selection> for WithParam {
        fn into(self) -> Selection {
            match self {
                Self::BlockList(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::block_list::_outputs());
                    let mut builder = Selection::builder("BlockList");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
                Self::IncomingBlock(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::incoming_block::_outputs());
                    let mut builder = Selection::builder("IncomingBlock");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        SetSessionToken(String),
        SetTwitterAccessToken(String),
        SetTwitterAccessTokenSecret(String),
        SetCreatedAt(chrono::DateTime<chrono::FixedOffset>),
        SetUpdatedAt(chrono::DateTime<chrono::FixedOffset>),
        LinkBlockList(Vec<super::block_list::UniqueWhereParam>),
        UnlinkBlockList(Vec<super::block_list::UniqueWhereParam>),
        LinkIncomingBlock(Vec<super::incoming_block::UniqueWhereParam>),
        UnlinkIncomingBlock(Vec<super::incoming_block::UniqueWhereParam>),
    }
    impl Into<(String, PrismaValue)> for SetParam {
        fn into(self) -> (String, PrismaValue) {
            match self {
                SetParam::SetId(value) => ("id".to_string(), PrismaValue::String(value)),
                SetParam::SetSessionToken(value) => {
                    ("sessionToken".to_string(), PrismaValue::String(value))
                }
                SetParam::SetTwitterAccessToken(value) => {
                    ("twitterAccessToken".to_string(), PrismaValue::String(value))
                }
                SetParam::SetTwitterAccessTokenSecret(value) => (
                    "twitterAccessTokenSecret".to_string(),
                    PrismaValue::String(value),
                ),
                SetParam::SetCreatedAt(value) => {
                    ("createdAt".to_string(), PrismaValue::DateTime(value))
                }
                SetParam::SetUpdatedAt(value) => {
                    ("updatedAt".to_string(), PrismaValue::DateTime(value))
                }
                SetParam::LinkBlockList(where_params) => (
                    "BlockList".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(transform_equals(
                            where_params
                                .into_iter()
                                .map(Into::<super::block_list::WhereParam>::into),
                        )),
                    )]),
                ),
                SetParam::UnlinkBlockList(where_params) => (
                    "BlockList".to_string(),
                    PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        PrismaValue::Object(
                            transform_equals(
                                where_params
                                    .into_iter()
                                    .map(Into::<super::block_list::WhereParam>::into),
                            )
                            .into_iter()
                            .collect(),
                        ),
                    )]),
                ),
                SetParam::LinkIncomingBlock(where_params) => (
                    "IncomingBlock".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(transform_equals(
                            where_params
                                .into_iter()
                                .map(Into::<super::incoming_block::WhereParam>::into),
                        )),
                    )]),
                ),
                SetParam::UnlinkIncomingBlock(where_params) => (
                    "IncomingBlock".to_string(),
                    PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        PrismaValue::Object(
                            transform_equals(
                                where_params
                                    .into_iter()
                                    .map(Into::<super::incoming_block::WhereParam>::into),
                            )
                            .into_iter()
                            .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(Direction),
        SessionToken(Direction),
        TwitterAccessToken(Direction),
        TwitterAccessTokenSecret(Direction),
        CreatedAt(Direction),
        UpdatedAt(Direction),
    }
    impl Into<(String, PrismaValue)> for OrderByParam {
        fn into(self) -> (String, PrismaValue) {
            match self {
                Self::Id(direction) => {
                    ("id".to_string(), PrismaValue::String(direction.to_string()))
                }
                Self::SessionToken(direction) => (
                    "sessionToken".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::TwitterAccessToken(direction) => (
                    "twitterAccessToken".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::TwitterAccessTokenSecret(direction) => (
                    "twitterAccessTokenSecret".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::CreatedAt(direction) => (
                    "createdAt".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::UpdatedAt(direction) => (
                    "updatedAt".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum Cursor {
        Id(String),
        TwitterAccessToken(String),
        TwitterAccessTokenSecret(String),
    }
    impl Into<(String, PrismaValue)> for Cursor {
        fn into(self) -> (String, PrismaValue) {
            match self {
                Self::Id(cursor) => ("id".to_string(), PrismaValue::String(cursor)),
                Self::TwitterAccessToken(cursor) => (
                    "twitterAccessToken".to_string(),
                    PrismaValue::String(cursor),
                ),
                Self::TwitterAccessTokenSecret(cursor) => (
                    "twitterAccessTokenSecret".to_string(),
                    PrismaValue::String(cursor),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(String),
        IdInVec(Vec<String>),
        IdNotInVec(Vec<String>),
        IdLt(String),
        IdLte(String),
        IdGt(String),
        IdGte(String),
        IdContains(String),
        IdStartsWith(String),
        IdEndsWith(String),
        IdNot(String),
        SessionTokenEquals(String),
        SessionTokenInVec(Vec<String>),
        SessionTokenNotInVec(Vec<String>),
        SessionTokenLt(String),
        SessionTokenLte(String),
        SessionTokenGt(String),
        SessionTokenGte(String),
        SessionTokenContains(String),
        SessionTokenStartsWith(String),
        SessionTokenEndsWith(String),
        SessionTokenNot(String),
        TwitterAccessTokenEquals(String),
        TwitterAccessTokenInVec(Vec<String>),
        TwitterAccessTokenNotInVec(Vec<String>),
        TwitterAccessTokenLt(String),
        TwitterAccessTokenLte(String),
        TwitterAccessTokenGt(String),
        TwitterAccessTokenGte(String),
        TwitterAccessTokenContains(String),
        TwitterAccessTokenStartsWith(String),
        TwitterAccessTokenEndsWith(String),
        TwitterAccessTokenNot(String),
        TwitterAccessTokenSecretEquals(String),
        TwitterAccessTokenSecretInVec(Vec<String>),
        TwitterAccessTokenSecretNotInVec(Vec<String>),
        TwitterAccessTokenSecretLt(String),
        TwitterAccessTokenSecretLte(String),
        TwitterAccessTokenSecretGt(String),
        TwitterAccessTokenSecretGte(String),
        TwitterAccessTokenSecretContains(String),
        TwitterAccessTokenSecretStartsWith(String),
        TwitterAccessTokenSecretEndsWith(String),
        TwitterAccessTokenSecretNot(String),
        CreatedAtEquals(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        CreatedAtNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        CreatedAtLt(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtLte(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtGt(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtGte(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtNot(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtEquals(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        UpdatedAtNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        UpdatedAtLt(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtLte(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtGt(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtGte(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtNot(chrono::DateTime<chrono::FixedOffset>),
        BlockListSome(Vec<super::block_list::WhereParam>),
        BlockListEvery(Vec<super::block_list::WhereParam>),
        BlockListNone(Vec<super::block_list::WhereParam>),
        IncomingBlockSome(Vec<super::incoming_block::WhereParam>),
        IncomingBlockEvery(Vec<super::incoming_block::WhereParam>),
        IncomingBlockNone(Vec<super::incoming_block::WhereParam>),
    }
    impl Into<SerializedWhere> for WhereParam {
        fn into(self) -> SerializedWhere {
            match self {
                Self::Not(value) => (
                    "NOT".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                            .collect(),
                    ),
                ),
                Self::Or(value) => (
                    "OR".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                            .collect(),
                    ),
                ),
                Self::IdEquals(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdInVec(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::IdNotInVec(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::IdLt(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdLte(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdGt(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdGte(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdContains(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdStartsWith(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdEndsWith(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdNot(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::SessionTokenEquals(value) => (
                    "sessionToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::SessionTokenInVec(value) => (
                    "sessionToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::SessionTokenNotInVec(value) => (
                    "sessionToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::SessionTokenLt(value) => (
                    "sessionToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::SessionTokenLte(value) => (
                    "sessionToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::SessionTokenGt(value) => (
                    "sessionToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::SessionTokenGte(value) => (
                    "sessionToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::SessionTokenContains(value) => (
                    "sessionToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::SessionTokenStartsWith(value) => (
                    "sessionToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::SessionTokenEndsWith(value) => (
                    "sessionToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::SessionTokenNot(value) => (
                    "sessionToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TwitterAccessTokenEquals(value) => (
                    "twitterAccessToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TwitterAccessTokenInVec(value) => (
                    "twitterAccessToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::TwitterAccessTokenNotInVec(value) => (
                    "twitterAccessToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::TwitterAccessTokenLt(value) => (
                    "twitterAccessToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TwitterAccessTokenLte(value) => (
                    "twitterAccessToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TwitterAccessTokenGt(value) => (
                    "twitterAccessToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TwitterAccessTokenGte(value) => (
                    "twitterAccessToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TwitterAccessTokenContains(value) => (
                    "twitterAccessToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TwitterAccessTokenStartsWith(value) => (
                    "twitterAccessToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TwitterAccessTokenEndsWith(value) => (
                    "twitterAccessToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TwitterAccessTokenNot(value) => (
                    "twitterAccessToken".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TwitterAccessTokenSecretEquals(value) => (
                    "twitterAccessTokenSecret".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TwitterAccessTokenSecretInVec(value) => (
                    "twitterAccessTokenSecret".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::TwitterAccessTokenSecretNotInVec(value) => (
                    "twitterAccessTokenSecret".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::TwitterAccessTokenSecretLt(value) => (
                    "twitterAccessTokenSecret".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TwitterAccessTokenSecretLte(value) => (
                    "twitterAccessTokenSecret".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TwitterAccessTokenSecretGt(value) => (
                    "twitterAccessTokenSecret".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TwitterAccessTokenSecretGte(value) => (
                    "twitterAccessTokenSecret".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TwitterAccessTokenSecretContains(value) => (
                    "twitterAccessTokenSecret".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TwitterAccessTokenSecretStartsWith(value) => (
                    "twitterAccessTokenSecret".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TwitterAccessTokenSecretEndsWith(value) => (
                    "twitterAccessTokenSecret".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TwitterAccessTokenSecretNot(value) => (
                    "twitterAccessTokenSecret".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::CreatedAtEquals(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtInVec(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::CreatedAtNotInVec(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::CreatedAtLt(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtLte(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtGt(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtGte(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtNot(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtEquals(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtInVec(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::UpdatedAtNotInVec(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::UpdatedAtLt(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtLte(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtGt(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtGte(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtNot(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::BlockListSome(value) => (
                    "BlockList".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::BlockListEvery(value) => (
                    "BlockList".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::BlockListNone(value) => (
                    "BlockList".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::IncomingBlockSome(value) => (
                    "IncomingBlock".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::IncomingBlockEvery(value) => (
                    "IncomingBlock".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::IncomingBlockNone(value) => (
                    "IncomingBlock".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        TwitterAccessTokenEquals(String),
        TwitterAccessTokenSecretEquals(String),
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::TwitterAccessTokenEquals(value) => {
                    Self::TwitterAccessTokenEquals(value)
                }
                UniqueWhereParam::TwitterAccessTokenSecretEquals(value) => {
                    Self::TwitterAccessTokenSecretEquals(value)
                }
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<Operator<Self>> for WhereParam {
        fn from(op: Operator<Self>) -> Self {
            match op {
                Operator::Not(value) => Self::Not(value),
                Operator::And(value) => Self::And(value),
                Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = prisma_client_rust::UniqueArgs<WithParam>;
    pub type ManyArgs = prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, Cursor>;
    pub type Create<'a> = prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
    pub type FindUnique<'a> =
        prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
    pub type FindMany<'a> = prisma_client_rust::FindMany<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        Cursor,
        SetParam,
        Data,
    >;
    pub type FindFirst<'a> =
        prisma_client_rust::FindFirst<'a, WhereParam, WithParam, OrderByParam, Cursor, Data>;
    pub type Update<'a> = prisma_client_rust::Update<'a, WhereParam, SetParam, WithParam, Data>;
    pub type UpdateMany<'a> = prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
    pub type Upsert<'a> = prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
    pub type Delete<'a> = prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
    pub type DeleteMany<'a> = prisma_client_rust::DeleteMany<'a, WhereParam>;
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn create(
            self,
            session_token: session_token::Set,
            twitter_access_token: twitter_access_token::Set,
            twitter_access_token_secret: twitter_access_token_secret::Set,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.push(session_token.into());
            _params.push(twitter_access_token.into());
            _params.push(twitter_access_token_secret.into());
            Create::new(
                self.client._new_query_context(),
                QueryInfo::new("User", _outputs()),
                _params,
            )
        }
        pub fn find_unique(self, param: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(
                self.client._new_query_context(),
                QueryInfo::new("User", _outputs()),
                param.into(),
            )
        }
        pub fn find_first(self, params: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(
                self.client._new_query_context(),
                QueryInfo::new("User", _outputs()),
                params,
            )
        }
        pub fn find_many(self, params: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(
                self.client._new_query_context(),
                QueryInfo::new("User", _outputs()),
                params,
            )
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            _create: (
                session_token::Set,
                twitter_access_token::Set,
                twitter_access_token_secret::Set,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            let (session_token, twitter_access_token, twitter_access_token_secret, mut _params) =
                _create;
            _params.push(session_token.into());
            _params.push(twitter_access_token.into());
            _params.push(twitter_access_token_secret.into());
            Upsert::new(
                self.client._new_query_context(),
                QueryInfo::new("User", _outputs()),
                _where.into(),
                _params,
                _update,
            )
        }
    }
}
pub mod block_list {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::Id(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::IdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::IdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::IdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::IdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::IdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::IdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::IdEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::IdNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
    }
    pub mod owner {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::OwnerIs(value)
        }
        pub fn is_not(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::OwnerIsNot(value)
        }
        pub struct Fetch {
            args: user::UniqueArgs,
        }
        impl Fetch {
            pub fn with(mut self, params: impl Into<user::WithParam>) -> Self {
                self.args = self.args.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Owner(fetch.args)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch {
                args: user::UniqueArgs::new(),
            }
        }
        pub fn link<T: From<Link>>(value: user::UniqueWhereParam) -> T {
            Link(value).into()
        }
        pub struct Link(user::UniqueWhereParam);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkOwner(value.0)
            }
        }
    }
    pub mod owner_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::OwnerIdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::OwnerId(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::OwnerId(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::OwnerIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::OwnerIdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::OwnerIdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::OwnerIdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::OwnerIdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::OwnerIdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::OwnerIdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::OwnerIdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::OwnerIdEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::OwnerIdNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetOwnerId(value.0)
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::CreatedAtInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::CreatedAtNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtNot(value)
        }
        pub struct Set(chrono::DateTime<chrono::FixedOffset>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetCreatedAt(value.0)
            }
        }
    }
    pub mod updated_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::UpdatedAt(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::UpdatedAtInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::UpdatedAtNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtNot(value)
        }
        pub struct Set(chrono::DateTime<chrono::FixedOffset>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUpdatedAt(value.0)
            }
        }
    }
    pub mod block_list_item {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<block_list_item::WhereParam>) -> WhereParam {
            WhereParam::BlockListItemSome(value)
        }
        pub fn every(value: Vec<block_list_item::WhereParam>) -> WhereParam {
            WhereParam::BlockListItemEvery(value)
        }
        pub fn none(value: Vec<block_list_item::WhereParam>) -> WhereParam {
            WhereParam::BlockListItemNone(value)
        }
        pub struct Fetch {
            args: block_list_item::ManyArgs,
        }
        impl Fetch {
            pub fn with(mut self, params: impl Into<block_list_item::WithParam>) -> Self {
                self.args = self.args.with(params.into());
                self
            }
            pub fn order_by(mut self, param: block_list_item::OrderByParam) -> Self {
                self.args = self.args.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.args = self.args.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.args = self.args.take(value);
                self
            }
            pub fn cursor(mut self, value: impl Into<block_list_item::Cursor>) -> Self {
                self.args = self.args.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::BlockListItem(fetch.args)
            }
        }
        pub fn fetch(params: Vec<block_list_item::WhereParam>) -> Fetch {
            Fetch {
                args: block_list_item::ManyArgs::new(params),
            }
        }
        pub fn link<T: From<Link>>(params: Vec<block_list_item::UniqueWhereParam>) -> T {
            Link(params).into()
        }
        pub fn unlink(params: Vec<block_list_item::UniqueWhereParam>) -> SetParam {
            SetParam::UnlinkBlockListItem(params)
        }
        pub struct Link(Vec<block_list_item::UniqueWhereParam>);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkBlockListItem(value.0)
            }
        }
    }
    pub fn _outputs() -> Vec<Selection> {
        ["id", "ownerId", "createdAt", "updatedAt"]
            .into_iter()
            .map(|o| {
                let builder = Selection::builder(o);
                builder.build()
            })
            .collect()
    }
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "owner")]
        pub owner: Option<Box<super::user::Data>>,
        #[serde(rename = "ownerId")]
        pub owner_id: String,
        #[serde(rename = "createdAt")]
        pub created_at: chrono::DateTime<chrono::FixedOffset>,
        #[serde(rename = "updatedAt")]
        pub updated_at: chrono::DateTime<chrono::FixedOffset>,
        #[serde(rename = "BlockListItem")]
        pub block_list_item: Option<Vec<super::block_list_item::Data>>,
    }
    impl Data {
        pub fn owner(&self) -> Result<&super::user::Data, &'static str> {
            self.owner
                .as_ref()
                .ok_or("Attempted to access 'owner' but did not fetch it using the .with() syntax")
                .map(|v| v.as_ref())
        }
        pub fn block_list_item(&self) -> Result<&Vec<super::block_list_item::Data>, &'static str> {
            self . block_list_item . as_ref () . ok_or ("Attempted to access 'block_list_item' but did not fetch it using the .with() syntax")
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Owner(super::user::UniqueArgs),
        BlockListItem(super::block_list_item::ManyArgs),
    }
    impl Into<Selection> for WithParam {
        fn into(self) -> Selection {
            match self {
                Self::Owner(args) => {
                    let mut selections = super::user::_outputs();
                    selections.extend(args.with_params.into_iter().map(Into::<Selection>::into));
                    let mut builder = Selection::builder("owner");
                    builder.nested_selections(selections);
                    builder.build()
                }
                Self::BlockListItem(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::block_list_item::_outputs());
                    let mut builder = Selection::builder("BlockListItem");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        LinkOwner(super::user::UniqueWhereParam),
        SetOwnerId(String),
        SetCreatedAt(chrono::DateTime<chrono::FixedOffset>),
        SetUpdatedAt(chrono::DateTime<chrono::FixedOffset>),
        LinkBlockListItem(Vec<super::block_list_item::UniqueWhereParam>),
        UnlinkBlockListItem(Vec<super::block_list_item::UniqueWhereParam>),
    }
    impl Into<(String, PrismaValue)> for SetParam {
        fn into(self) -> (String, PrismaValue) {
            match self {
                SetParam::SetId(value) => ("id".to_string(), PrismaValue::String(value)),
                SetParam::LinkOwner(where_param) => (
                    "owner".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(transform_equals(
                            vec![Into::<super::user::WhereParam>::into(where_param)].into_iter(),
                        )),
                    )]),
                ),
                SetParam::SetOwnerId(value) => ("ownerId".to_string(), PrismaValue::String(value)),
                SetParam::SetCreatedAt(value) => {
                    ("createdAt".to_string(), PrismaValue::DateTime(value))
                }
                SetParam::SetUpdatedAt(value) => {
                    ("updatedAt".to_string(), PrismaValue::DateTime(value))
                }
                SetParam::LinkBlockListItem(where_params) => (
                    "BlockListItem".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(transform_equals(
                            where_params
                                .into_iter()
                                .map(Into::<super::block_list_item::WhereParam>::into),
                        )),
                    )]),
                ),
                SetParam::UnlinkBlockListItem(where_params) => (
                    "BlockListItem".to_string(),
                    PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        PrismaValue::Object(
                            transform_equals(
                                where_params
                                    .into_iter()
                                    .map(Into::<super::block_list_item::WhereParam>::into),
                            )
                            .into_iter()
                            .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(Direction),
        OwnerId(Direction),
        CreatedAt(Direction),
        UpdatedAt(Direction),
    }
    impl Into<(String, PrismaValue)> for OrderByParam {
        fn into(self) -> (String, PrismaValue) {
            match self {
                Self::Id(direction) => {
                    ("id".to_string(), PrismaValue::String(direction.to_string()))
                }
                Self::OwnerId(direction) => (
                    "ownerId".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::CreatedAt(direction) => (
                    "createdAt".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::UpdatedAt(direction) => (
                    "updatedAt".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum Cursor {
        Id(String),
        OwnerId(String),
    }
    impl Into<(String, PrismaValue)> for Cursor {
        fn into(self) -> (String, PrismaValue) {
            match self {
                Self::Id(cursor) => ("id".to_string(), PrismaValue::String(cursor)),
                Self::OwnerId(cursor) => ("ownerId".to_string(), PrismaValue::String(cursor)),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(String),
        IdInVec(Vec<String>),
        IdNotInVec(Vec<String>),
        IdLt(String),
        IdLte(String),
        IdGt(String),
        IdGte(String),
        IdContains(String),
        IdStartsWith(String),
        IdEndsWith(String),
        IdNot(String),
        OwnerIs(Vec<super::user::WhereParam>),
        OwnerIsNot(Vec<super::user::WhereParam>),
        OwnerIdEquals(String),
        OwnerIdInVec(Vec<String>),
        OwnerIdNotInVec(Vec<String>),
        OwnerIdLt(String),
        OwnerIdLte(String),
        OwnerIdGt(String),
        OwnerIdGte(String),
        OwnerIdContains(String),
        OwnerIdStartsWith(String),
        OwnerIdEndsWith(String),
        OwnerIdNot(String),
        CreatedAtEquals(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        CreatedAtNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        CreatedAtLt(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtLte(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtGt(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtGte(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtNot(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtEquals(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        UpdatedAtNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        UpdatedAtLt(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtLte(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtGt(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtGte(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtNot(chrono::DateTime<chrono::FixedOffset>),
        BlockListItemSome(Vec<super::block_list_item::WhereParam>),
        BlockListItemEvery(Vec<super::block_list_item::WhereParam>),
        BlockListItemNone(Vec<super::block_list_item::WhereParam>),
    }
    impl Into<SerializedWhere> for WhereParam {
        fn into(self) -> SerializedWhere {
            match self {
                Self::Not(value) => (
                    "NOT".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                            .collect(),
                    ),
                ),
                Self::Or(value) => (
                    "OR".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                            .collect(),
                    ),
                ),
                Self::IdEquals(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdInVec(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::IdNotInVec(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::IdLt(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdLte(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdGt(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdGte(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdContains(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdStartsWith(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdEndsWith(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdNot(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::OwnerIs(value) => (
                    "owner".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::OwnerIsNot(value) => (
                    "owner".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::OwnerIdEquals(value) => (
                    "ownerId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::OwnerIdInVec(value) => (
                    "ownerId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::OwnerIdNotInVec(value) => (
                    "ownerId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::OwnerIdLt(value) => (
                    "ownerId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::OwnerIdLte(value) => (
                    "ownerId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::OwnerIdGt(value) => (
                    "ownerId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::OwnerIdGte(value) => (
                    "ownerId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::OwnerIdContains(value) => (
                    "ownerId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::OwnerIdStartsWith(value) => (
                    "ownerId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::OwnerIdEndsWith(value) => (
                    "ownerId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::OwnerIdNot(value) => (
                    "ownerId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::CreatedAtEquals(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtInVec(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::CreatedAtNotInVec(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::CreatedAtLt(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtLte(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtGt(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtGte(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtNot(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtEquals(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtInVec(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::UpdatedAtNotInVec(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::UpdatedAtLt(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtLte(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtGt(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtGte(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtNot(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::BlockListItemSome(value) => (
                    "BlockListItem".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::BlockListItemEvery(value) => (
                    "BlockListItem".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::BlockListItemNone(value) => (
                    "BlockListItem".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        OwnerIdEquals(String),
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::OwnerIdEquals(value) => Self::OwnerIdEquals(value),
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<Operator<Self>> for WhereParam {
        fn from(op: Operator<Self>) -> Self {
            match op {
                Operator::Not(value) => Self::Not(value),
                Operator::And(value) => Self::And(value),
                Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = prisma_client_rust::UniqueArgs<WithParam>;
    pub type ManyArgs = prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, Cursor>;
    pub type Create<'a> = prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
    pub type FindUnique<'a> =
        prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
    pub type FindMany<'a> = prisma_client_rust::FindMany<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        Cursor,
        SetParam,
        Data,
    >;
    pub type FindFirst<'a> =
        prisma_client_rust::FindFirst<'a, WhereParam, WithParam, OrderByParam, Cursor, Data>;
    pub type Update<'a> = prisma_client_rust::Update<'a, WhereParam, SetParam, WithParam, Data>;
    pub type UpdateMany<'a> = prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
    pub type Upsert<'a> = prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
    pub type Delete<'a> = prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
    pub type DeleteMany<'a> = prisma_client_rust::DeleteMany<'a, WhereParam>;
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn create(self, owner: owner::Link, mut _params: Vec<SetParam>) -> Create<'a> {
            _params.push(owner.into());
            Create::new(
                self.client._new_query_context(),
                QueryInfo::new("BlockList", _outputs()),
                _params,
            )
        }
        pub fn find_unique(self, param: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(
                self.client._new_query_context(),
                QueryInfo::new("BlockList", _outputs()),
                param.into(),
            )
        }
        pub fn find_first(self, params: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(
                self.client._new_query_context(),
                QueryInfo::new("BlockList", _outputs()),
                params,
            )
        }
        pub fn find_many(self, params: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(
                self.client._new_query_context(),
                QueryInfo::new("BlockList", _outputs()),
                params,
            )
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            _create: (owner::Link, Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            let (owner, mut _params) = _create;
            _params.push(owner.into());
            Upsert::new(
                self.client._new_query_context(),
                QueryInfo::new("BlockList", _outputs()),
                _where.into(),
                _params,
                _update,
            )
        }
    }
}
pub mod block_list_item {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::Id(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::IdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::IdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::IdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::IdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::IdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::IdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::IdEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::IdNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
    }
    pub mod block_list {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<block_list::WhereParam>) -> WhereParam {
            WhereParam::BlockListIs(value)
        }
        pub fn is_not(value: Vec<block_list::WhereParam>) -> WhereParam {
            WhereParam::BlockListIsNot(value)
        }
        pub struct Fetch {
            args: block_list::UniqueArgs,
        }
        impl Fetch {
            pub fn with(mut self, params: impl Into<block_list::WithParam>) -> Self {
                self.args = self.args.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::BlockList(fetch.args)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch {
                args: block_list::UniqueArgs::new(),
            }
        }
        pub fn link<T: From<Link>>(value: block_list::UniqueWhereParam) -> T {
            Link(value).into()
        }
        pub struct Link(block_list::UniqueWhereParam);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkBlockList(value.0)
            }
        }
    }
    pub mod block_list_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::BlockListIdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::BlockListId(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::BlockListIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::BlockListIdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::BlockListIdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::BlockListIdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::BlockListIdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::BlockListIdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::BlockListIdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::BlockListIdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::BlockListIdEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::BlockListIdNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetBlockListId(value.0)
            }
        }
    }
    pub mod twitter_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::TwitterAtEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::TwitterAt(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::TwitterAtInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::TwitterAtNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::TwitterAtLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::TwitterAtLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::TwitterAtGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::TwitterAtGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::TwitterAtContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::TwitterAtStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::TwitterAtEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::TwitterAtNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetTwitterAt(value.0)
            }
        }
    }
    pub mod twitter_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::TwitterIdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::TwitterId(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::TwitterIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::TwitterIdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::TwitterIdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::TwitterIdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::TwitterIdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::TwitterIdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::TwitterIdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::TwitterIdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::TwitterIdEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::TwitterIdNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetTwitterId(value.0)
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::CreatedAtInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::CreatedAtNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtNot(value)
        }
        pub struct Set(chrono::DateTime<chrono::FixedOffset>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetCreatedAt(value.0)
            }
        }
    }
    pub mod updated_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::UpdatedAt(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::UpdatedAtInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::UpdatedAtNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtNot(value)
        }
        pub struct Set(chrono::DateTime<chrono::FixedOffset>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUpdatedAt(value.0)
            }
        }
    }
    pub mod incoming_block {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<incoming_block::WhereParam>) -> WhereParam {
            WhereParam::IncomingBlockSome(value)
        }
        pub fn every(value: Vec<incoming_block::WhereParam>) -> WhereParam {
            WhereParam::IncomingBlockEvery(value)
        }
        pub fn none(value: Vec<incoming_block::WhereParam>) -> WhereParam {
            WhereParam::IncomingBlockNone(value)
        }
        pub struct Fetch {
            args: incoming_block::ManyArgs,
        }
        impl Fetch {
            pub fn with(mut self, params: impl Into<incoming_block::WithParam>) -> Self {
                self.args = self.args.with(params.into());
                self
            }
            pub fn order_by(mut self, param: incoming_block::OrderByParam) -> Self {
                self.args = self.args.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.args = self.args.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.args = self.args.take(value);
                self
            }
            pub fn cursor(mut self, value: impl Into<incoming_block::Cursor>) -> Self {
                self.args = self.args.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::IncomingBlock(fetch.args)
            }
        }
        pub fn fetch(params: Vec<incoming_block::WhereParam>) -> Fetch {
            Fetch {
                args: incoming_block::ManyArgs::new(params),
            }
        }
        pub fn link<T: From<Link>>(params: Vec<incoming_block::UniqueWhereParam>) -> T {
            Link(params).into()
        }
        pub fn unlink(params: Vec<incoming_block::UniqueWhereParam>) -> SetParam {
            SetParam::UnlinkIncomingBlock(params)
        }
        pub struct Link(Vec<incoming_block::UniqueWhereParam>);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkIncomingBlock(value.0)
            }
        }
    }
    pub fn _outputs() -> Vec<Selection> {
        [
            "id",
            "blockListId",
            "twitterAt",
            "twitterId",
            "createdAt",
            "updatedAt",
        ]
        .into_iter()
        .map(|o| {
            let builder = Selection::builder(o);
            builder.build()
        })
        .collect()
    }
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "blockList")]
        pub block_list: Option<Box<super::block_list::Data>>,
        #[serde(rename = "blockListId")]
        pub block_list_id: String,
        #[serde(rename = "twitterAt")]
        pub twitter_at: String,
        #[serde(rename = "twitterId")]
        pub twitter_id: String,
        #[serde(rename = "createdAt")]
        pub created_at: chrono::DateTime<chrono::FixedOffset>,
        #[serde(rename = "updatedAt")]
        pub updated_at: chrono::DateTime<chrono::FixedOffset>,
        #[serde(rename = "IncomingBlock")]
        pub incoming_block: Option<Vec<super::incoming_block::Data>>,
    }
    impl Data {
        pub fn block_list(&self) -> Result<&super::block_list::Data, &'static str> {
            self . block_list . as_ref () . ok_or ("Attempted to access 'block_list' but did not fetch it using the .with() syntax") . map (| v | v . as_ref ())
        }
        pub fn incoming_block(&self) -> Result<&Vec<super::incoming_block::Data>, &'static str> {
            self . incoming_block . as_ref () . ok_or ("Attempted to access 'incoming_block' but did not fetch it using the .with() syntax")
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        BlockList(super::block_list::UniqueArgs),
        IncomingBlock(super::incoming_block::ManyArgs),
    }
    impl Into<Selection> for WithParam {
        fn into(self) -> Selection {
            match self {
                Self::BlockList(args) => {
                    let mut selections = super::block_list::_outputs();
                    selections.extend(args.with_params.into_iter().map(Into::<Selection>::into));
                    let mut builder = Selection::builder("blockList");
                    builder.nested_selections(selections);
                    builder.build()
                }
                Self::IncomingBlock(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(super::incoming_block::_outputs());
                    let mut builder = Selection::builder("IncomingBlock");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        LinkBlockList(super::block_list::UniqueWhereParam),
        SetBlockListId(String),
        SetTwitterAt(String),
        SetTwitterId(String),
        SetCreatedAt(chrono::DateTime<chrono::FixedOffset>),
        SetUpdatedAt(chrono::DateTime<chrono::FixedOffset>),
        LinkIncomingBlock(Vec<super::incoming_block::UniqueWhereParam>),
        UnlinkIncomingBlock(Vec<super::incoming_block::UniqueWhereParam>),
    }
    impl Into<(String, PrismaValue)> for SetParam {
        fn into(self) -> (String, PrismaValue) {
            match self {
                SetParam::SetId(value) => ("id".to_string(), PrismaValue::String(value)),
                SetParam::LinkBlockList(where_param) => (
                    "blockList".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(transform_equals(
                            vec![Into::<super::block_list::WhereParam>::into(where_param)]
                                .into_iter(),
                        )),
                    )]),
                ),
                SetParam::SetBlockListId(value) => {
                    ("blockListId".to_string(), PrismaValue::String(value))
                }
                SetParam::SetTwitterAt(value) => {
                    ("twitterAt".to_string(), PrismaValue::String(value))
                }
                SetParam::SetTwitterId(value) => {
                    ("twitterId".to_string(), PrismaValue::String(value))
                }
                SetParam::SetCreatedAt(value) => {
                    ("createdAt".to_string(), PrismaValue::DateTime(value))
                }
                SetParam::SetUpdatedAt(value) => {
                    ("updatedAt".to_string(), PrismaValue::DateTime(value))
                }
                SetParam::LinkIncomingBlock(where_params) => (
                    "IncomingBlock".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(transform_equals(
                            where_params
                                .into_iter()
                                .map(Into::<super::incoming_block::WhereParam>::into),
                        )),
                    )]),
                ),
                SetParam::UnlinkIncomingBlock(where_params) => (
                    "IncomingBlock".to_string(),
                    PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        PrismaValue::Object(
                            transform_equals(
                                where_params
                                    .into_iter()
                                    .map(Into::<super::incoming_block::WhereParam>::into),
                            )
                            .into_iter()
                            .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(Direction),
        BlockListId(Direction),
        TwitterAt(Direction),
        TwitterId(Direction),
        CreatedAt(Direction),
        UpdatedAt(Direction),
    }
    impl Into<(String, PrismaValue)> for OrderByParam {
        fn into(self) -> (String, PrismaValue) {
            match self {
                Self::Id(direction) => {
                    ("id".to_string(), PrismaValue::String(direction.to_string()))
                }
                Self::BlockListId(direction) => (
                    "blockListId".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::TwitterAt(direction) => (
                    "twitterAt".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::TwitterId(direction) => (
                    "twitterId".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::CreatedAt(direction) => (
                    "createdAt".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::UpdatedAt(direction) => (
                    "updatedAt".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum Cursor {
        Id(String),
    }
    impl Into<(String, PrismaValue)> for Cursor {
        fn into(self) -> (String, PrismaValue) {
            match self {
                Self::Id(cursor) => ("id".to_string(), PrismaValue::String(cursor)),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(String),
        IdInVec(Vec<String>),
        IdNotInVec(Vec<String>),
        IdLt(String),
        IdLte(String),
        IdGt(String),
        IdGte(String),
        IdContains(String),
        IdStartsWith(String),
        IdEndsWith(String),
        IdNot(String),
        BlockListIs(Vec<super::block_list::WhereParam>),
        BlockListIsNot(Vec<super::block_list::WhereParam>),
        BlockListIdEquals(String),
        BlockListIdInVec(Vec<String>),
        BlockListIdNotInVec(Vec<String>),
        BlockListIdLt(String),
        BlockListIdLte(String),
        BlockListIdGt(String),
        BlockListIdGte(String),
        BlockListIdContains(String),
        BlockListIdStartsWith(String),
        BlockListIdEndsWith(String),
        BlockListIdNot(String),
        TwitterAtEquals(String),
        TwitterAtInVec(Vec<String>),
        TwitterAtNotInVec(Vec<String>),
        TwitterAtLt(String),
        TwitterAtLte(String),
        TwitterAtGt(String),
        TwitterAtGte(String),
        TwitterAtContains(String),
        TwitterAtStartsWith(String),
        TwitterAtEndsWith(String),
        TwitterAtNot(String),
        TwitterIdEquals(String),
        TwitterIdInVec(Vec<String>),
        TwitterIdNotInVec(Vec<String>),
        TwitterIdLt(String),
        TwitterIdLte(String),
        TwitterIdGt(String),
        TwitterIdGte(String),
        TwitterIdContains(String),
        TwitterIdStartsWith(String),
        TwitterIdEndsWith(String),
        TwitterIdNot(String),
        CreatedAtEquals(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        CreatedAtNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        CreatedAtLt(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtLte(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtGt(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtGte(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtNot(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtEquals(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        UpdatedAtNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        UpdatedAtLt(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtLte(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtGt(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtGte(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtNot(chrono::DateTime<chrono::FixedOffset>),
        IncomingBlockSome(Vec<super::incoming_block::WhereParam>),
        IncomingBlockEvery(Vec<super::incoming_block::WhereParam>),
        IncomingBlockNone(Vec<super::incoming_block::WhereParam>),
    }
    impl Into<SerializedWhere> for WhereParam {
        fn into(self) -> SerializedWhere {
            match self {
                Self::Not(value) => (
                    "NOT".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                            .collect(),
                    ),
                ),
                Self::Or(value) => (
                    "OR".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                            .collect(),
                    ),
                ),
                Self::IdEquals(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdInVec(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::IdNotInVec(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::IdLt(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdLte(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdGt(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdGte(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdContains(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdStartsWith(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdEndsWith(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdNot(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::BlockListIs(value) => (
                    "blockList".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::BlockListIsNot(value) => (
                    "blockList".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::BlockListIdEquals(value) => (
                    "blockListId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::BlockListIdInVec(value) => (
                    "blockListId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::BlockListIdNotInVec(value) => (
                    "blockListId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::BlockListIdLt(value) => (
                    "blockListId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::BlockListIdLte(value) => (
                    "blockListId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::BlockListIdGt(value) => (
                    "blockListId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::BlockListIdGte(value) => (
                    "blockListId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::BlockListIdContains(value) => (
                    "blockListId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::BlockListIdStartsWith(value) => (
                    "blockListId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::BlockListIdEndsWith(value) => (
                    "blockListId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::BlockListIdNot(value) => (
                    "blockListId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TwitterAtEquals(value) => (
                    "twitterAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TwitterAtInVec(value) => (
                    "twitterAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::TwitterAtNotInVec(value) => (
                    "twitterAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::TwitterAtLt(value) => (
                    "twitterAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TwitterAtLte(value) => (
                    "twitterAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TwitterAtGt(value) => (
                    "twitterAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TwitterAtGte(value) => (
                    "twitterAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TwitterAtContains(value) => (
                    "twitterAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TwitterAtStartsWith(value) => (
                    "twitterAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TwitterAtEndsWith(value) => (
                    "twitterAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TwitterAtNot(value) => (
                    "twitterAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TwitterIdEquals(value) => (
                    "twitterId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TwitterIdInVec(value) => (
                    "twitterId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::TwitterIdNotInVec(value) => (
                    "twitterId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::TwitterIdLt(value) => (
                    "twitterId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TwitterIdLte(value) => (
                    "twitterId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TwitterIdGt(value) => (
                    "twitterId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TwitterIdGte(value) => (
                    "twitterId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TwitterIdContains(value) => (
                    "twitterId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TwitterIdStartsWith(value) => (
                    "twitterId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TwitterIdEndsWith(value) => (
                    "twitterId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::TwitterIdNot(value) => (
                    "twitterId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::CreatedAtEquals(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtInVec(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::CreatedAtNotInVec(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::CreatedAtLt(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtLte(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtGt(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtGte(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtNot(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtEquals(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtInVec(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::UpdatedAtNotInVec(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::UpdatedAtLt(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtLte(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtGt(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtGte(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtNot(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::IncomingBlockSome(value) => (
                    "IncomingBlock".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::IncomingBlockEvery(value) => (
                    "IncomingBlock".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::IncomingBlockNone(value) => (
                    "IncomingBlock".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<Operator<Self>> for WhereParam {
        fn from(op: Operator<Self>) -> Self {
            match op {
                Operator::Not(value) => Self::Not(value),
                Operator::And(value) => Self::And(value),
                Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = prisma_client_rust::UniqueArgs<WithParam>;
    pub type ManyArgs = prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, Cursor>;
    pub type Create<'a> = prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
    pub type FindUnique<'a> =
        prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
    pub type FindMany<'a> = prisma_client_rust::FindMany<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        Cursor,
        SetParam,
        Data,
    >;
    pub type FindFirst<'a> =
        prisma_client_rust::FindFirst<'a, WhereParam, WithParam, OrderByParam, Cursor, Data>;
    pub type Update<'a> = prisma_client_rust::Update<'a, WhereParam, SetParam, WithParam, Data>;
    pub type UpdateMany<'a> = prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
    pub type Upsert<'a> = prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
    pub type Delete<'a> = prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
    pub type DeleteMany<'a> = prisma_client_rust::DeleteMany<'a, WhereParam>;
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn create(
            self,
            block_list: block_list::Link,
            twitter_at: twitter_at::Set,
            twitter_id: twitter_id::Set,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.push(block_list.into());
            _params.push(twitter_at.into());
            _params.push(twitter_id.into());
            Create::new(
                self.client._new_query_context(),
                QueryInfo::new("BlockListItem", _outputs()),
                _params,
            )
        }
        pub fn find_unique(self, param: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(
                self.client._new_query_context(),
                QueryInfo::new("BlockListItem", _outputs()),
                param.into(),
            )
        }
        pub fn find_first(self, params: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(
                self.client._new_query_context(),
                QueryInfo::new("BlockListItem", _outputs()),
                params,
            )
        }
        pub fn find_many(self, params: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(
                self.client._new_query_context(),
                QueryInfo::new("BlockListItem", _outputs()),
                params,
            )
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            _create: (
                block_list::Link,
                twitter_at::Set,
                twitter_id::Set,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            let (block_list, twitter_at, twitter_id, mut _params) = _create;
            _params.push(block_list.into());
            _params.push(twitter_at.into());
            _params.push(twitter_id.into());
            Upsert::new(
                self.client._new_query_context(),
                QueryInfo::new("BlockListItem", _outputs()),
                _where.into(),
                _params,
                _update,
            )
        }
    }
}
pub mod incoming_block {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::Id(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::IdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::IdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::IdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::IdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::IdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::IdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::IdEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::IdNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
    }
    pub mod user {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::UserIs(value)
        }
        pub fn is_not(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::UserIsNot(value)
        }
        pub struct Fetch {
            args: user::UniqueArgs,
        }
        impl Fetch {
            pub fn with(mut self, params: impl Into<user::WithParam>) -> Self {
                self.args = self.args.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::User(fetch.args)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch {
                args: user::UniqueArgs::new(),
            }
        }
        pub fn link<T: From<Link>>(value: user::UniqueWhereParam) -> T {
            Link(value).into()
        }
        pub struct Link(user::UniqueWhereParam);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkUser(value.0)
            }
        }
    }
    pub mod user_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::UserIdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::UserId(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::UserIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::UserIdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::UserIdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::UserIdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::UserIdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::UserIdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::UserIdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::UserIdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::UserIdEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::UserIdNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUserId(value.0)
            }
        }
    }
    pub mod block_list_item {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<block_list_item::WhereParam>) -> WhereParam {
            WhereParam::BlockListItemIs(value)
        }
        pub fn is_not(value: Vec<block_list_item::WhereParam>) -> WhereParam {
            WhereParam::BlockListItemIsNot(value)
        }
        pub struct Fetch {
            args: block_list_item::UniqueArgs,
        }
        impl Fetch {
            pub fn with(mut self, params: impl Into<block_list_item::WithParam>) -> Self {
                self.args = self.args.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::BlockListItem(fetch.args)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch {
                args: block_list_item::UniqueArgs::new(),
            }
        }
        pub fn link<T: From<Link>>(value: block_list_item::UniqueWhereParam) -> T {
            Link(value).into()
        }
        pub struct Link(block_list_item::UniqueWhereParam);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkBlockListItem(value.0)
            }
        }
    }
    pub mod block_list_item_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::BlockListItemIdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::BlockListItemId(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::BlockListItemIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::BlockListItemIdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::BlockListItemIdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::BlockListItemIdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::BlockListItemIdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::BlockListItemIdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::BlockListItemIdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::BlockListItemIdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::BlockListItemIdEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::BlockListItemIdNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetBlockListItemId(value.0)
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::CreatedAtInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::CreatedAtNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtNot(value)
        }
        pub struct Set(chrono::DateTime<chrono::FixedOffset>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetCreatedAt(value.0)
            }
        }
    }
    pub mod updated_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::UpdatedAt(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::UpdatedAtInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::UpdatedAtNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtNot(value)
        }
        pub struct Set(chrono::DateTime<chrono::FixedOffset>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUpdatedAt(value.0)
            }
        }
    }
    pub fn _outputs() -> Vec<Selection> {
        ["id", "userId", "blockListItemId", "createdAt", "updatedAt"]
            .into_iter()
            .map(|o| {
                let builder = Selection::builder(o);
                builder.build()
            })
            .collect()
    }
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "user")]
        pub user: Option<Box<super::user::Data>>,
        #[serde(rename = "userId")]
        pub user_id: String,
        #[serde(rename = "blockListItem")]
        pub block_list_item: Option<Box<super::block_list_item::Data>>,
        #[serde(rename = "blockListItemId")]
        pub block_list_item_id: String,
        #[serde(rename = "createdAt")]
        pub created_at: chrono::DateTime<chrono::FixedOffset>,
        #[serde(rename = "updatedAt")]
        pub updated_at: chrono::DateTime<chrono::FixedOffset>,
    }
    impl Data {
        pub fn user(&self) -> Result<&super::user::Data, &'static str> {
            self.user
                .as_ref()
                .ok_or("Attempted to access 'user' but did not fetch it using the .with() syntax")
                .map(|v| v.as_ref())
        }
        pub fn block_list_item(&self) -> Result<&super::block_list_item::Data, &'static str> {
            self . block_list_item . as_ref () . ok_or ("Attempted to access 'block_list_item' but did not fetch it using the .with() syntax") . map (| v | v . as_ref ())
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        User(super::user::UniqueArgs),
        BlockListItem(super::block_list_item::UniqueArgs),
    }
    impl Into<Selection> for WithParam {
        fn into(self) -> Selection {
            match self {
                Self::User(args) => {
                    let mut selections = super::user::_outputs();
                    selections.extend(args.with_params.into_iter().map(Into::<Selection>::into));
                    let mut builder = Selection::builder("user");
                    builder.nested_selections(selections);
                    builder.build()
                }
                Self::BlockListItem(args) => {
                    let mut selections = super::block_list_item::_outputs();
                    selections.extend(args.with_params.into_iter().map(Into::<Selection>::into));
                    let mut builder = Selection::builder("blockListItem");
                    builder.nested_selections(selections);
                    builder.build()
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        LinkUser(super::user::UniqueWhereParam),
        SetUserId(String),
        LinkBlockListItem(super::block_list_item::UniqueWhereParam),
        SetBlockListItemId(String),
        SetCreatedAt(chrono::DateTime<chrono::FixedOffset>),
        SetUpdatedAt(chrono::DateTime<chrono::FixedOffset>),
    }
    impl Into<(String, PrismaValue)> for SetParam {
        fn into(self) -> (String, PrismaValue) {
            match self {
                SetParam::SetId(value) => ("id".to_string(), PrismaValue::String(value)),
                SetParam::LinkUser(where_param) => (
                    "user".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(transform_equals(
                            vec![Into::<super::user::WhereParam>::into(where_param)].into_iter(),
                        )),
                    )]),
                ),
                SetParam::SetUserId(value) => ("userId".to_string(), PrismaValue::String(value)),
                SetParam::LinkBlockListItem(where_param) => (
                    "blockListItem".to_string(),
                    PrismaValue::Object(vec![(
                        "connect".to_string(),
                        PrismaValue::Object(transform_equals(
                            vec![Into::<super::block_list_item::WhereParam>::into(
                                where_param,
                            )]
                            .into_iter(),
                        )),
                    )]),
                ),
                SetParam::SetBlockListItemId(value) => {
                    ("blockListItemId".to_string(), PrismaValue::String(value))
                }
                SetParam::SetCreatedAt(value) => {
                    ("createdAt".to_string(), PrismaValue::DateTime(value))
                }
                SetParam::SetUpdatedAt(value) => {
                    ("updatedAt".to_string(), PrismaValue::DateTime(value))
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(Direction),
        UserId(Direction),
        BlockListItemId(Direction),
        CreatedAt(Direction),
        UpdatedAt(Direction),
    }
    impl Into<(String, PrismaValue)> for OrderByParam {
        fn into(self) -> (String, PrismaValue) {
            match self {
                Self::Id(direction) => {
                    ("id".to_string(), PrismaValue::String(direction.to_string()))
                }
                Self::UserId(direction) => (
                    "userId".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::BlockListItemId(direction) => (
                    "blockListItemId".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::CreatedAt(direction) => (
                    "createdAt".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
                Self::UpdatedAt(direction) => (
                    "updatedAt".to_string(),
                    PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum Cursor {
        Id(String),
    }
    impl Into<(String, PrismaValue)> for Cursor {
        fn into(self) -> (String, PrismaValue) {
            match self {
                Self::Id(cursor) => ("id".to_string(), PrismaValue::String(cursor)),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(String),
        IdInVec(Vec<String>),
        IdNotInVec(Vec<String>),
        IdLt(String),
        IdLte(String),
        IdGt(String),
        IdGte(String),
        IdContains(String),
        IdStartsWith(String),
        IdEndsWith(String),
        IdNot(String),
        UserIs(Vec<super::user::WhereParam>),
        UserIsNot(Vec<super::user::WhereParam>),
        UserIdEquals(String),
        UserIdInVec(Vec<String>),
        UserIdNotInVec(Vec<String>),
        UserIdLt(String),
        UserIdLte(String),
        UserIdGt(String),
        UserIdGte(String),
        UserIdContains(String),
        UserIdStartsWith(String),
        UserIdEndsWith(String),
        UserIdNot(String),
        BlockListItemIs(Vec<super::block_list_item::WhereParam>),
        BlockListItemIsNot(Vec<super::block_list_item::WhereParam>),
        BlockListItemIdEquals(String),
        BlockListItemIdInVec(Vec<String>),
        BlockListItemIdNotInVec(Vec<String>),
        BlockListItemIdLt(String),
        BlockListItemIdLte(String),
        BlockListItemIdGt(String),
        BlockListItemIdGte(String),
        BlockListItemIdContains(String),
        BlockListItemIdStartsWith(String),
        BlockListItemIdEndsWith(String),
        BlockListItemIdNot(String),
        CreatedAtEquals(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        CreatedAtNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        CreatedAtLt(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtLte(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtGt(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtGte(chrono::DateTime<chrono::FixedOffset>),
        CreatedAtNot(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtEquals(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        UpdatedAtNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        UpdatedAtLt(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtLte(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtGt(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtGte(chrono::DateTime<chrono::FixedOffset>),
        UpdatedAtNot(chrono::DateTime<chrono::FixedOffset>),
    }
    impl Into<SerializedWhere> for WhereParam {
        fn into(self) -> SerializedWhere {
            match self {
                Self::Not(value) => (
                    "NOT".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                            .collect(),
                    ),
                ),
                Self::Or(value) => (
                    "OR".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| PrismaValue::Object(transform_equals(vec![v].into_iter())))
                            .collect(),
                    ),
                ),
                Self::IdEquals(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdInVec(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::IdNotInVec(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::IdLt(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdLte(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdGt(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdGte(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdContains(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdStartsWith(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdEndsWith(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::IdNot(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIs(value) => (
                    "user".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::UserIsNot(value) => (
                    "user".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::UserIdEquals(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdInVec(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::UserIdNotInVec(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::UserIdLt(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdLte(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdGt(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdGte(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdContains(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdStartsWith(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdEndsWith(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::UserIdNot(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::BlockListItemIs(value) => (
                    "blockListItem".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::BlockListItemIsNot(value) => (
                    "blockListItem".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        PrismaValue::Object(transform_equals(
                            value.into_iter().map(Into::<SerializedWhere>::into),
                        )),
                    )]),
                ),
                Self::BlockListItemIdEquals(value) => (
                    "blockListItemId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::BlockListItemIdInVec(value) => (
                    "blockListItemId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::BlockListItemIdNotInVec(value) => (
                    "blockListItemId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value.into_iter().map(|v| PrismaValue::String(v)).collect(),
                        ),
                    )]),
                ),
                Self::BlockListItemIdLt(value) => (
                    "blockListItemId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::BlockListItemIdLte(value) => (
                    "blockListItemId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::BlockListItemIdGt(value) => (
                    "blockListItemId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::BlockListItemIdGte(value) => (
                    "blockListItemId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::BlockListItemIdContains(value) => (
                    "blockListItemId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::BlockListItemIdStartsWith(value) => (
                    "blockListItemId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::BlockListItemIdEndsWith(value) => (
                    "blockListItemId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::BlockListItemIdNot(value) => (
                    "blockListItemId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value),
                    )]),
                ),
                Self::CreatedAtEquals(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtInVec(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::CreatedAtNotInVec(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::CreatedAtLt(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtLte(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtGt(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtGte(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAtNot(value) => (
                    "createdAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtEquals(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtInVec(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::UpdatedAtNotInVec(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::UpdatedAtLt(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtLte(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtGt(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtGte(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
                Self::UpdatedAtNot(value) => (
                    "updatedAt".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::DateTime(value),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<Operator<Self>> for WhereParam {
        fn from(op: Operator<Self>) -> Self {
            match op {
                Operator::Not(value) => Self::Not(value),
                Operator::And(value) => Self::And(value),
                Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = prisma_client_rust::UniqueArgs<WithParam>;
    pub type ManyArgs = prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, Cursor>;
    pub type Create<'a> = prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
    pub type FindUnique<'a> =
        prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
    pub type FindMany<'a> = prisma_client_rust::FindMany<
        'a,
        WhereParam,
        WithParam,
        OrderByParam,
        Cursor,
        SetParam,
        Data,
    >;
    pub type FindFirst<'a> =
        prisma_client_rust::FindFirst<'a, WhereParam, WithParam, OrderByParam, Cursor, Data>;
    pub type Update<'a> = prisma_client_rust::Update<'a, WhereParam, SetParam, WithParam, Data>;
    pub type UpdateMany<'a> = prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
    pub type Upsert<'a> = prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
    pub type Delete<'a> = prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
    pub type DeleteMany<'a> = prisma_client_rust::DeleteMany<'a, WhereParam>;
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn create(
            self,
            user: user::Link,
            block_list_item: block_list_item::Link,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.push(user.into());
            _params.push(block_list_item.into());
            Create::new(
                self.client._new_query_context(),
                QueryInfo::new("IncomingBlock", _outputs()),
                _params,
            )
        }
        pub fn find_unique(self, param: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(
                self.client._new_query_context(),
                QueryInfo::new("IncomingBlock", _outputs()),
                param.into(),
            )
        }
        pub fn find_first(self, params: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(
                self.client._new_query_context(),
                QueryInfo::new("IncomingBlock", _outputs()),
                params,
            )
        }
        pub fn find_many(self, params: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(
                self.client._new_query_context(),
                QueryInfo::new("IncomingBlock", _outputs()),
                params,
            )
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            _create: (user::Link, block_list_item::Link, Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            let (user, block_list_item, mut _params) = _create;
            _params.push(user.into());
            _params.push(block_list_item.into());
            Upsert::new(
                self.client._new_query_context(),
                QueryInfo::new("IncomingBlock", _outputs()),
                _where.into(),
                _params,
                _update,
            )
        }
    }
}
pub mod _prisma {
    use super::*;
    use prisma_client_rust::{
        queries::QueryContext,
        query_core::{QueryExecutor, QuerySchema},
        raw, ExecuteRaw, QueryRaw,
    };
    use serde::{Deserialize, Serialize};
    use std::fmt;
    use std::sync::Arc;
    pub struct PrismaClient {
        executor: Box<dyn QueryExecutor + Send + Sync + 'static>,
        query_schema: Arc<QuerySchema>,
    }
    impl fmt::Debug for PrismaClient {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("PrismaClient").finish()
        }
    }
    impl PrismaClient {
        pub(super) fn _new_query_context(&self) -> QueryContext {
            QueryContext::new(&self.executor, self.query_schema.clone())
        }
        pub(super) fn _new(
            executor: Box<dyn QueryExecutor + Send + Sync + 'static>,
            query_schema: Arc<QuerySchema>,
        ) -> Self {
            Self {
                executor,
                query_schema,
            }
        }
        pub async fn _query_raw<T: serde::de::DeserializeOwned>(
            &self,
            query: raw::Raw,
        ) -> QueryResult<Vec<T>> {
            QueryRaw::new(
                QueryContext::new(&self.executor, self.query_schema.clone()),
                query,
                DATABASE_STR,
            )
            .exec()
            .await
        }
        pub async fn _execute_raw(&self, query: raw::Raw) -> QueryResult<i64> {
            ExecuteRaw::new(
                QueryContext::new(&self.executor, self.query_schema.clone()),
                query,
                DATABASE_STR,
            )
            .exec()
            .await
        }
        pub fn user(&self) -> user::Actions {
            user::Actions { client: &self }
        }
        pub fn block_list(&self) -> block_list::Actions {
            block_list::Actions { client: &self }
        }
        pub fn block_list_item(&self) -> block_list_item::Actions {
            block_list_item::Actions { client: &self }
        }
        pub fn incoming_block(&self) -> incoming_block::Actions {
            incoming_block::Actions { client: &self }
        }
    }
    #[derive(Debug, Clone, Copy, Serialize, Deserialize)]
    pub enum UserScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "sessionToken")]
        SessionToken,
        #[serde(rename = "twitterAccessToken")]
        TwitterAccessToken,
        #[serde(rename = "twitterAccessTokenSecret")]
        TwitterAccessTokenSecret,
        #[serde(rename = "createdAt")]
        CreatedAt,
        #[serde(rename = "updatedAt")]
        UpdatedAt,
    }
    impl ToString for UserScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::SessionToken => "sessionToken".to_string(),
                Self::TwitterAccessToken => "twitterAccessToken".to_string(),
                Self::TwitterAccessTokenSecret => "twitterAccessTokenSecret".to_string(),
                Self::CreatedAt => "createdAt".to_string(),
                Self::UpdatedAt => "updatedAt".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, Serialize, Deserialize)]
    pub enum BlockListScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "ownerId")]
        OwnerId,
        #[serde(rename = "createdAt")]
        CreatedAt,
        #[serde(rename = "updatedAt")]
        UpdatedAt,
    }
    impl ToString for BlockListScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::OwnerId => "ownerId".to_string(),
                Self::CreatedAt => "createdAt".to_string(),
                Self::UpdatedAt => "updatedAt".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, Serialize, Deserialize)]
    pub enum BlockListItemScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "blockListId")]
        BlockListId,
        #[serde(rename = "twitterAt")]
        TwitterAt,
        #[serde(rename = "twitterId")]
        TwitterId,
        #[serde(rename = "createdAt")]
        CreatedAt,
        #[serde(rename = "updatedAt")]
        UpdatedAt,
    }
    impl ToString for BlockListItemScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::BlockListId => "blockListId".to_string(),
                Self::TwitterAt => "twitterAt".to_string(),
                Self::TwitterId => "twitterId".to_string(),
                Self::CreatedAt => "createdAt".to_string(),
                Self::UpdatedAt => "updatedAt".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, Serialize, Deserialize)]
    pub enum IncomingBlockScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "userId")]
        UserId,
        #[serde(rename = "blockListItemId")]
        BlockListItemId,
        #[serde(rename = "createdAt")]
        CreatedAt,
        #[serde(rename = "updatedAt")]
        UpdatedAt,
    }
    impl ToString for IncomingBlockScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::UserId => "userId".to_string(),
                Self::BlockListItemId => "blockListItemId".to_string(),
                Self::CreatedAt => "createdAt".to_string(),
                Self::UpdatedAt => "updatedAt".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, Serialize, Deserialize)]
    pub enum SortOrder {
        #[serde(rename = "asc")]
        Asc,
        #[serde(rename = "desc")]
        Desc,
    }
    impl ToString for SortOrder {
        fn to_string(&self) -> String {
            match self {
                Self::Asc => "asc".to_string(),
                Self::Desc => "desc".to_string(),
            }
        }
    }
}
pub use _prisma::PrismaClient;
